{
    "contents" : "#function to run EP on the astronomy data\nastro.EP = function(fit = NULL, data = NULL, J = 360, K = 6, prior.Mu = rep(5.5,4), S = 10, P = 4, \n                    SMOOTH = 0.9, randomSites = FALSE, parallel = FALSE){\n\n  # Extract data\n  x <- data$x;\n  y <- data$y;\n  bin <- data$bin;\n  \n  # Group the Sites randomly\n  bin.samp <- sample(unique(bin), replace = FALSE)\n  \n  # Initialize global and local natural parameters\n  Sigma.k.inv.Mu <- Sigma.k.inv <- Sigma.inv <- Sigma.inv.Mu <- Post.Sigma <- list();\n  Post.Mu <- matrix(0, ncol = P, nrow = S + 1);\n  for(k in 1:K) Sigma.k.inv.Mu[[k]] <- rep(0,P);\n  for(k in 1:K) Sigma.k.inv[[k]] <- diag(P)*0;\n  Sigma.inv[[1]] <- Sigma.inv[[2]] <- diag(P)*K/10;\n  Sigma.inv.Mu[[1]] <- Sigma.inv.Mu[[2]] <- Sigma.inv[[1]]%*%prior.Mu;\n  Post.Sigma[[1]] <- solve(Sigma.inv[[1]]);\n  Post.Mu[1,] <- as.vector(Post.Sigma[[1]]%*%Sigma.inv.Mu[[1]]);\n\n  # timer\n  init.time <- proc.time();\n\n  # The actual algorithm...\n  for(s in 1:S){\n    #update natural parameters from previous iteration for parallel/serial\n    if (parallel) {\n      Sigma.inv[[s+1]] <- Sigma.inv[[1]];\n      Sigma.inv.Mu[[s+1]] <- Sigma.inv.Mu[[1]];\n    } else if (s > 1) {\n      Sigma.inv[[s]] <- Sigma.inv[[s-1]];\n      Sigma.inv.Mu[[s]] <- Sigma.inv.Mu[[s-1]];\n    }\n    \n    for(k in 1:K){\n      cat(\" Current Iteration Status: [\", s, \" out of \", S, \"] \\n\");\n      cat(\" Current Partition Status: [\", k, \" out of \", K, \"] \\n\");\n      \n      # 1. Update the Cavity Distribution...\n      Sigma.inv.cav <- Sigma.inv[[s]] - Sigma.k.inv[[k]];\n      Sigma.inv.Mu.cav <- Sigma.inv.Mu[[s]] - Sigma.k.inv.Mu[[k]];\n      Sigma.cav <- solve(Sigma.inv.cav);\n      Sigma.cav <- (Sigma.cav+t(Sigma.cav))/2; #preserve symmetry\n      Mu.cav <- as.vector(Sigma.cav%*%Sigma.inv.Mu.cav);\n    \n      # 2. Find tilted distribution in Stan...\n      # Extract current partition of the data...\n      if (randomSites) { subset <- which(bin %in% bin.samp[((k-1)*J/K+1) : (k*J/K)]); }\n      else { subset <- which(bin <= k*J/K & bin > (k-1)*J/K); }\n      y.k <- y[subset];\n      x.k <- x[subset];\n      bin.k <- (ceiling(bin[subset] - 1))%%(J/K) + 1;\n      tilt.data <- list(N=length(y.k), M=P, B=J/K, x=x.k, y=y.k, bin=bin.k, Mu_Cav=Mu.cav, Sig_Cav=Sigma.cav);\n    \n      # Fit tilted distribution in Stan....\n      tilt.fit <- sampling(fit, data = tilt.data, iter = 100, chains = 4);\n    \n      # Extract mean and covariance matrix....\n      Mu.tilt <- colMeans(extract(tilt.fit)$phi);\n      Sigma.tilt <- matrix(0, nrow = P, ncol = P);\n      for(i in 1:P)\n        for(j in 1:P)\n          Sigma.tilt[i,j] <- cov(extract(tilt.fit)$phi[,i], extract(tilt.fit)$phi[,j]);\n      # Bias correction on covariance matrix....\n      n <- length(extract(tilt.fit)$phi[,1]);\n      Sigma.inv.tilt <- solve(Sigma.tilt)*(n-P-2)/(n-1);\n      Sigma.inv.Mu.tilt <- Sigma.inv.tilt%*%Mu.tilt;\n    \n      # 3. Update the Site Distribution\n      Sigma.k.inv[[k]] <- Sigma.inv.tilt - Sigma.inv.cav; \n      Sigma.k.inv.Mu[[k]] <- Sigma.inv.Mu.tilt - Sigma.inv.Mu.cav;\n      \n      # 4. Update g(phi) in Parallel/Serial\n      if (parallel) {\n        Sigma.inv[[s+1]] <- Sigma.inv.tilt + Sigma.inv[[s+1]];\n        Sigma.inv.Mu[[s+1]] <- Sigma.inv.Mu.tilt + Sigma.inv.Mu[[s+1]];\n      } else {\n        Sigma.inv[[s]] <- SMOOTH*Sigma.inv.tilt + (1-SMOOTH)*Sigma.inv[[s]];\n        Sigma.inv.Mu[[s]] <- SMOOTH*Sigma.inv.Mu.tilt + (1-SMOOTH)*Sigma.inv.Mu[[s]];\n      }\n    }\n    \n    # Convert Natural Parameters Back Into Usual Framework\n    if (parallel) {\n      Post.Sigma[[s+1]] = solve(Sigma.inv[[s+1]]);\n      Post.Mu[s+1,] = as.vector(Post.Sigma[[s+1]]%*%Sigma.inv.Mu[[s+1]]);\n    } else if (s > 1) {\n      Post.Sigma[[s+1]] = solve(Sigma.inv[[s]]);\n      Post.Mu[s+1,] = as.vector(Post.Sigma[[s+1]]%*%Sigma.inv.Mu[[s]]);\n    }\n  }\n\n  #save the total time elapsed\n  final.time <- proc.time();\n  \n  #plot phi v. s, and return all values\n  EP.plot(exp(Post.Mu), J, K, S);\n  return(list(Post.Sigma = Post.Sigma, Post.Mu = Post.Mu,\n              time = final.time - init.time));\n}\n\nEP.plot = function(data=NULL, J=360, K=6, S=10, params=expression(mu[alpha],tau[alpha],beta,sigma)){\n  P <- ncol(data);\n  plot(c(0:S), data[,1], xlab=\"Iteration\", ylab=expression(phi), \n       ylim=c(min(data),max(data)), type='l', main=paste(\"EP: J =\",J,\", K =\",K));\n  for(p in 2:P)\n    lines(c(0:S), data[,p], col=p);\n  legend(\"bottomleft\", col=c(1:P), legend=params, lty=rep(1,P));\n}\n",
    "created" : 1422734273559.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1974081821",
    "id" : "9D1F10A1",
    "lastKnownWriteTime" : 1423349717,
    "path" : "~/Dropbox/Documents/School/Columbia/Research/Astronomy/Hierarchical Model/Expectation Propagation/EP.R",
    "project_path" : "EP.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}