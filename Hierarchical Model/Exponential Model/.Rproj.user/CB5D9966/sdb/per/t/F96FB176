{
    "contents" : "Model0_EP = function(fit = NULL, data = NULL, prior.Mu = 0, prior.Sig = 10, S = 10, \n              SMOOTH = 0.9, randomSites = FALSE, parallel = FALSE, mc_iter = 100){\n  \n  # Extract data\n  y <- data$y;\n  \n  # Initialize global and local natural parameters\n  Sigma.inv <- Sigma.inv.Mu <- Post.Sigma <- list();\n  Post.Mu <- matrix(0, ncol = 1, nrow = S + 1);\n  Sigma.inv[[1]] <- Sigma.inv[[2]] <- 1/prior.Sig;\n  Sigma.inv.Mu[[1]] <- Sigma.inv.Mu[[2]] <- Sigma.inv[[1]] * prior.Mu;\n  Post.Sigma[[1]] <- 1/Sigma.inv[[1]];\n  Post.Mu[1,] <- as.vector(Post.Sigma[[1]] * Sigma.inv.Mu[[1]]);\n  init.data <- list()\n  \n  # timer\n  init.time <- proc.time();\n  times <- matrix(0,nrow=S,ncol=3)\n  \n  # The actual algorithm...\n  for(s in 1:S){\n    #update natural parameters from previous iteration for parallel/serial\n    if (parallel) {\n      Sigma.inv[[s+1]] <- Sigma.inv[[1]];\n      Sigma.inv.Mu[[s+1]] <- Sigma.inv.Mu[[1]];\n    } else if (s > 1) {\n      Sigma.inv[[s]] <- Sigma.inv[[s-1]];\n      Sigma.inv.Mu[[s]] <- Sigma.inv.Mu[[s-1]];\n    }\n    \n    cat(\" Current Iteration Status: [\", s, \" out of \", S, \"] \\n\");\n    \n    # 1. Update the Cavity Distribution...\n    Sigma.inv.cav <- Sigma.inv[[s]];\n    Sigma.inv.Mu.cav <- Sigma.inv.Mu[[s]];\n    Sigma.cav <- 1/(Sigma.inv.cav);\n    Mu.cav <- as.vector(Sigma.cav * Sigma.inv.Mu.cav);\n    \n    # Force the same flat prior\n    Sigma.cav <- 1/(Sigma.inv[[1]]);\n    \n    # 2. Find tilted distribution in Stan...\n    # Extract current partition of the data...\n    tilt.data <- list(N = length(y), y = y, Mu_Cav = Mu.cav, Sig_Cav = Sigma.cav);\n    \n    # Fit tilted distribution in Stan....\n    for(i in 1:4) { init.data[[i]] <- list(phi = Mu.cav);}\n    times[s,] <- system.time(tilt.fit <- sampling(fit, data = tilt.data, iter = mc_iter, chains = 4, init = init.data))[1:3];\n    \n    # Extract mean and covariance matrix....\n    Mu.tilt <- mean(extract(tilt.fit)$phi);\n    Sigma.tilt <- sd(extract(tilt.fit)$phi);\n    # Bias correction on covariance matrix....\n    n <- length(extract(tilt.fit)$phi);\n    Sigma.inv.tilt <- 1/(Sigma.tilt)*(n-1-2)/(n-1);\n    Sigma.inv.Mu.tilt <- Sigma.inv.tilt * Mu.tilt;\n    \n    # 4. Update g(phi) in Parallel/Serial\n    if (parallel) {\n      Sigma.inv[[s+1]] <- Sigma.inv.tilt;\n      Sigma.inv.Mu[[s+1]] <- Sigma.inv.Mu.tilt;\n    } else {\n      Sigma.inv[[s]] <- SMOOTH*Sigma.inv.tilt + (1-SMOOTH)*Sigma.inv[[s]];\n      Sigma.inv.Mu[[s]] <- SMOOTH*Sigma.inv.Mu.tilt + (1-SMOOTH)*Sigma.inv.Mu[[s]];\n    }\n    \n    # Convert Natural Parameters Back Into Usual Framework\n    if (parallel) {\n      Post.Sigma[[s+1]] = 1/(Sigma.inv[[s+1]]);\n      Post.Mu[s+1,] = as.vector(Post.Sigma[[s+1]] * Sigma.inv.Mu[[s+1]]);\n    } else if (s > 1) {\n      Post.Sigma[[s+1]] = solve(Sigma.inv[[s]]);\n      Post.Mu[s+1,] = as.vector(Post.Sigma[[s+1]] * Sigma.inv.Mu[[s]]);\n    }\n  }\n  \n  #save the total time elapsed\n  final.time <- proc.time();\n  \n  #plot phi v. s, and return all values\n  return(list(Post.Sigma = Post.Sigma, Post.Mu = Post.Mu,\n              time = final.time - init.time, times = times));\n}",
    "created" : 1438749430501.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3629217471",
    "id" : "F96FB176",
    "lastKnownWriteTime" : 1438749556,
    "path" : "~/Library/Mobile Documents/com~apple~CloudDocs/School/Columbia/Research/Astronomy/Hierarchical Model/EP_Test/Model0_EP.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}